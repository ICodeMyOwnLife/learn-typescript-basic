"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var utils_1 = require("../utils");
var checks_1 = require("./checks");
var printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
function visitNode(visitingNode, sourceFile) {
    if (checks_1.isNameof(visitingNode))
        return getLiteral(getNameofAsString(visitingNode));
    if (checks_1.isNameofFull(visitingNode))
        return getLiteral(getNameofFullAsString(visitingNode));
    return visitingNode;
    function getLiteral(str) {
        if (str == null || str.trim().length === 0)
            return utils_1.throwError("Could not resolve string from expression: " + getNodeText(visitingNode));
        return ts.createLiteral(str);
    }
    function getNameofAsString(callExpr) {
        if (callExpr.arguments != null && callExpr.arguments.length > 0)
            return getLastPart(getNodeParts(callExpr.arguments[0]));
        else if (callExpr.typeArguments != null && callExpr.typeArguments.length > 0)
            return getLastPart(getNodeParts(callExpr.typeArguments[0]));
        return undefined;
        function getLastPart(parts) {
            return parts[parts.length - 1];
        }
    }
    function getNameofFullAsString(callExpr) {
        if (callExpr.arguments != null && shouldUseArguments())
            return getPartsAsString(getNodeParts(callExpr.arguments[0]), getCount(callExpr.arguments[1]));
        if (callExpr.typeArguments != null && callExpr.typeArguments.length > 0)
            return getPartsAsString(getNodeParts(callExpr.typeArguments[0]), getCount(callExpr.arguments == null ? undefined : callExpr.arguments[0]));
        return undefined;
        function getPartsAsString(parts, count) {
            return getSubParts().join(".");
            function getSubParts() {
                if (count > 0) {
                    if (count > parts.length - 1)
                        return utils_1.throwError("Count of " + count + " was larger than max count of " + (parts.length - 1) + " for " + getNodeText(callExpr));
                    return parts.slice(count);
                }
                if (count < 0) {
                    if (Math.abs(count) > parts.length)
                        return utils_1.throwError("Count of " + count + " was larger than max count of " + parts.length * -1 + " for " + getNodeText(callExpr));
                    return parts.slice(parts.length + count);
                }
                return parts;
            }
        }
        function getCount(countExpr) {
            if (countExpr == null)
                return 0;
            if (ts.isNumericLiteral(countExpr) || ts.isPrefixUnaryExpression(countExpr)) {
                var result = parseInt(getNodeText(countExpr), 10);
                if (!isNaN(result))
                    return result;
            }
            return utils_1.throwError("Expected count to be a number, but was: " + getNodeText(countExpr));
        }
        function shouldUseArguments() {
            if (callExpr.arguments == null || callExpr.arguments.length === 0)
                return false;
            if (callExpr.typeArguments == null || callExpr.typeArguments.length === 0)
                return true;
            return ts.isFunctionLike(callExpr.arguments[0]);
        }
    }
    function getNodeParts(node) {
        if (ts.isPropertyAccessExpression(node))
            return getPropertyAccessExpressionParts(node);
        if (ts.isElementAccessExpression(node))
            return getElementAccessExpressionParts(node);
        if (ts.isArrowFunction(node))
            return getArrowFunctionParts(node);
        if (ts.isFunctionExpression(node))
            return getFunctionExpressionParts(node);
        if (ts.isNonNullExpression(node))
            return getNodeParts(node.expression);
        if (ts.isQualifiedName(node))
            return getQualifiedNameParts(node);
        if (ts.isTypeReferenceNode(node))
            return getNodeParts(node.typeName);
        return [getNodeText(node)];
    }
    function getFunctionExpressionParts(func) {
        return getNodeParts(getReturnStatementExpressionFromBlock(func.body)).slice(1);
    }
    function getArrowFunctionParts(func) {
        if (ts.isBlock(func.body))
            return getNodeParts(getReturnStatementExpressionFromBlock(func.body)).slice(1);
        return getNodeParts(func.body).slice(1);
    }
    function getReturnStatementExpressionFromBlock(block) {
        for (var _i = 0, _a = block.statements; _i < _a.length; _i++) {
            var statement = _a[_i];
            if (ts.isReturnStatement(statement) && statement.expression != null)
                return statement.expression;
        }
        return utils_1.throwError("Cound not find return statement with an expression in function expression: " + getNodeText(block));
    }
    function getElementAccessExpressionParts(elementAccessExpr) {
        if (ts.isElementAccessExpression(elementAccessExpr.expression))
            return addArgTextToArray(getElementAccessExpressionParts(elementAccessExpr.expression).slice());
        if (ts.isPropertyAccessExpression(elementAccessExpr.expression))
            return addArgTextToArray(getPropertyAccessExpressionParts(elementAccessExpr.expression).slice());
        return addArgTextToArray(getNodeParts(elementAccessExpr.expression).slice());
        function addArgTextToArray(items) {
            items[items.length - 1] += getArgumentExpression();
            return items;
        }
        function getArgumentExpression() {
            if (elementAccessExpr.argumentExpression == null)
                return "";
            return "[" + getNodeParts(elementAccessExpr.argumentExpression).join(".") + "]";
        }
    }
    function getQualifiedNameParts(name) {
        if (ts.isQualifiedName(name.left))
            return getQualifiedNameParts(name.left).concat(getNodeParts(name.right));
        return getNodeParts(name.left).concat(getNodeParts(name.right));
    }
    function getPropertyAccessExpressionParts(pae) {
        if (ts.isPropertyAccessExpression(pae.expression))
            return getPropertyAccessExpressionParts(pae.expression).concat(getNodeParts(pae.name));
        return getNodeParts(pae.expression).concat(getNodeParts(pae.name));
    }
    function getNodeText(node) {
        return printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);
    }
}
exports.visitNode = visitNode;
